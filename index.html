<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zip to Hospital Game</title>
  <style>
    body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
    #game { display: grid; grid-template-columns: repeat(6, 60px); grid-template-rows: repeat(6, 60px); gap: 2px; margin-top: 20px; touch-action: none; }
    .cell { width: 60px; height: 60px; background: #f0f0f0; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; font-weight: bold; font-size: 18px; }
    .numbered { background: #d9faff; }
    .visited { background: #88ff88; }
    .current { background: #ffe066; }
    .invalid { background: #ff6b6b; }
    .solution { background: #cfc; }
    #controls { margin-top: 10px; }
    canvas { position: absolute; pointer-events: none; z-index: 0; }
  </style>
</head>
<body>
<h2>Zip to Hospital</h2>
<div id="controls">
  Difficulty: 
  <select id="difficulty">
    <option value="8">8 Steps</option>
    <option value="10">10 Steps</option>
    <option value="12">12 Steps</option>
  </select>
  <button id="restart">Restart</button>
  <span id="timer">Time: 0.00s</span>
</div>
<div id="game"></div>
<canvas id="traceCanvas" width="360" height="360"></canvas>
<div id="message"></div>

<script>
(() => {
  const game = document.getElementById('game');
  const timerDisplay = document.getElementById('timer');
  const restartBtn = document.getElementById('restart');
  const difficultySelect = document.getElementById('difficulty');
  const message = document.getElementById('message');
  const canvas = document.getElementById('traceCanvas');
  const ctx = canvas.getContext('2d');

  const size = 6;
  let grid = [];
  let numberedPoints = [];
  let solutionPath = [];
  let currentIndex = 0;
  let dragging = false;
  let visitedPath = [];
  let visitedSet = new Set();
  let startTime = 0;
  let timerInterval = null;

  function createGrid() {
    game.innerHTML = '';
    grid = [];
    for (let r = 0; r < size; r++) {
      const row = [];
      for (let c = 0; c < size; c++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.dataset.r = r;
        cell.dataset.c = c;
        game.appendChild(cell);
        row.push(cell);
      }
      grid.push(row);
    }
  }

  function generateHamiltonianPath() {
    const visited = Array.from({ length: size }, () => Array(size).fill(false));
    const path = [];

    function backtrack(r, c) {
      if (path.length === size * size) return true;
      const directions = [ [0, 1], [1, 0], [0, -1], [-1, 0] ];
      for (let [dr, dc] of directions.sort(() => Math.random() - 0.5)) {
        const nr = r + dr, nc = c + dc;
        if (nr >= 0 && nr < size && nc >= 0 && nc < size && !visited[nr][nc]) {
          visited[nr][nc] = true;
          path.push([nr, nc]);
          if (backtrack(nr, nc)) return true;
          path.pop();
          visited[nr][nc] = false;
        }
      }
      return false;
    }

    let startR = Math.floor(Math.random() * size);
    let startC = Math.floor(Math.random() * size);
    visited[startR][startC] = true;
    path.push([startR, startC]);
    if (backtrack(startR, startC)) return path;
    return generateHamiltonianPath();
  }

  function selectNumberedPoints(path, count) {
    const step = Math.floor(path.length / count);
    return Array.from({ length: count }, (_, i) => path[i * step]);
  }

  function renderPoints() {
    for (let i = 0; i < numberedPoints.length; i++) {
      const [r, c] = numberedPoints[i];
      const cell = grid[r][c];
      cell.classList.add('numbered');
      cell.textContent = (i + 1);
    }
  }

  function drawTraceLine() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = 'blue';
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let i = 0; i < visitedPath.length; i++) {
      const [r, c] = visitedPath[i];
      const x = c * 60 + 30;
      const y = r * 60 + 30;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }

  function showSolution() {
    for (let [r, c] of solutionPath) {
      grid[r][c].classList.add('solution');
    }
  }

  function startTimer() {
    startTime = performance.now();
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      const elapsed = (performance.now() - startTime) / 1000;
      timerDisplay.textContent = `Time: ${elapsed.toFixed(2)}s`;
    }, 100);
  }

  function stopTimer() {
    if (timerInterval) clearInterval(timerInterval);
  }

  function resetGame() {
    createGrid();
    const n = parseInt(difficultySelect.value);
    const path = generateHamiltonianPath();
    solutionPath = [...path];
    numberedPoints = selectNumberedPoints(path, n);
    renderPoints();
    currentIndex = 0;
    visitedPath = [];
    visitedSet.clear();
    message.textContent = '';
    stopTimer();
    timerDisplay.textContent = 'Time: 0.00s';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  function handleCellHover(e) {
    if (!dragging) return;
    const cell = e.target;
    if (!cell.classList.contains('cell')) return;
    const r = parseInt(cell.dataset.r);
    const c = parseInt(cell.dataset.c);
    const key = `${r},${c}`;
    if (visitedSet.has(key)) return;

    if (visitedPath.length > 0) {
      const [lr, lc] = visitedPath[visitedPath.length - 1];
      if (!(Math.abs(r - lr) + Math.abs(c - lc) === 1)) return;
    }

    visitedPath.push([r, c]);
    visitedSet.add(key);
    cell.classList.add('visited');
    drawTraceLine();

    const [targetR, targetC] = numberedPoints[currentIndex];
    if (r === targetR && c === targetC) {
      currentIndex++;
      cell.classList.add('current');
      if (currentIndex === numberedPoints.length && visitedPath.length === size * size) {
        message.textContent = `ðŸŽ‰ Success! Time: ${((performance.now() - startTime) / 1000).toFixed(2)}s`;
        stopTimer();
        dragging = false;
      }
    } else if (grid[r][c].textContent !== '') {
      cell.classList.add('invalid');
      message.textContent = `âŒ Wrong number order!`;
      dragging = false;
      stopTimer();
      showSolution();
    }
  }

  game.addEventListener('mousedown', (e) => {
    if (e.target.classList.contains('cell')) {
      visitedPath = [];
      visitedSet.clear();
      for (let row of grid) {
        for (let cell of row) {
          cell.classList.remove('visited', 'invalid', 'current', 'solution');
        }
      }
      currentIndex = 0;
      dragging = true;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      startTimer();
    }
  });

  game.addEventListener('mouseup', () => dragging = false);
  game.addEventListener('mouseleave', () => dragging = false);
  game.addEventListener('mousemove', handleCellHover);

  restartBtn.onclick = resetGame;
  difficultySelect.onchange = resetGame;

  resetGame();
})();
</script>
</body>
</html>
