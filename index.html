<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Zip to Hospital Game</title>
  <style>
    #game {
      display: grid;
      grid-template-columns: repeat(6, 60px);
      grid-gap: 2px;
      position: relative;
    }
    .cell {
      width: 60px;
      height: 60px;
      background: #eee;
      font-size: 24px;
      text-align: center;
      line-height: 60px;
      font-weight: bold;
      position: relative;
      z-index: 1;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
  </style>
</head>
<body>
  <button onclick="restartGame()">Restart</button>
  <div id="game"></div>

  <script>
    const size = 6;
    const steps = 8; // Number of numbered points
    const game = document.getElementById("game");
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    let grid = [];
    let path = [];
    let numberedPoints = [];
    let currentStep = 0;
    let isDragging = false;
    let tracePath = [];

    function createGrid() {
      game.innerHTML = "";
      grid = [];
      const cellSize = 60;
      const gapSize = 2;
      canvas.width = size * cellSize + (size - 1) * gapSize;
      canvas.height = size * cellSize + (size - 1) * gapSize;

      for (let r = 0; r < size; r++) {
        const row = [];
        for (let c = 0; c < size; c++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.r = r;
          cell.dataset.c = c;
          cell.addEventListener("mousedown", handleStart);
          cell.addEventListener("mouseenter", handleEnter);
          cell.addEventListener("mouseup", handleEnd);
          game.appendChild(cell);
          row.push(cell);
        }
        grid.push(row);
      }
      game.appendChild(canvas);
    }

    function generateHamiltonianPath() {
      const visited = Array.from({ length: size }, () => Array(size).fill(false));
      const path = [];

      function backtrack(r, c) {
        if (path.length === size * size) return true;
        const directions = [
          [0, 1],
          [1, 0],
          [0, -1],
          [-1, 0]
        ];
        for (let [dr, dc] of directions.sort(() => Math.random() - 0.5)) {
          const nr = r + dr,
            nc = c + dc;
          if (nr >= 0 && nr < size && nc >= 0 && nc < size && !visited[nr][nc]) {
            visited[nr][nc] = true;
            path.push([nr, nc]);
            if (backtrack(nr, nc)) return true;
            path.pop();
            visited[nr][nc] = false;
          }
        }
        return false;
      }

      let startR = Math.floor(Math.random() * size);
      let startC = Math.floor(Math.random() * size);
      visited[startR][startC] = true;
      path.push([startR, startC]);
      if (backtrack(startR, startC)) return path;
      return generateHamiltonianPath();
    }

    function selectNumberedPoints(path, count) {
      const points = [];
      const step = Math.floor((path.length - 1) / (count - 1));
      for (let i = 0; i < count - 1; i++) {
        points.push(path[i * step]);
      }
      points.push(path[path.length - 1]);
      return points;
    }

    function renderPoints() {
      numberedPoints.forEach(([r, c], i) => {
        const cell = grid[r][c];
        cell.classList.add("numbered");
        if (i === 0) {
          cell.textContent = "üöë";
        } else if (i === numberedPoints.length - 1) {
          cell.textContent = "üè•";
        } else {
          cell.textContent = i + 1;
          cell.dataset.num = i + 1;
        }
      });
    }

    function drawTrace() {
      const cellSize = 60;
      const gapSize = 2;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (tracePath.length < 2) return;
      ctx.beginPath();
      const [r0, c0] = tracePath[0];
      ctx.moveTo(c0 * (cellSize + gapSize) + cellSize / 2, r0 * (cellSize + gapSize) + cellSize / 2);
      for (let i = 1; i < tracePath.length; i++) {
        const [r, c] = tracePath[i];
        ctx.lineTo(c * (cellSize + gapSize) + cellSize / 2, r * (cellSize + gapSize) + cellSize / 2);
      }
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 4;
      ctx.stroke();
    }

    function handleStart(e) {
      const r = parseInt(e.target.dataset.r);
      const c = parseInt(e.target.dataset.c);
      const [expectedR, expectedC] = numberedPoints[currentStep];
      if (r === expectedR && c === expectedC) {
        isDragging = true;
        tracePath = [[r, c]];
        drawTrace();
      }
    }

    function handleEnter(e) {
      if (!isDragging) return;
      const r = parseInt(e.target.dataset.r);
      const c = parseInt(e.target.dataset.c);
      const [lastR, lastC] = tracePath[tracePath.length - 1];
      if (Math.abs(r - lastR) + Math.abs(c - lastC) === 1) {
        const [expectedR, expectedC] = numberedPoints[currentStep + 1];
        if (r === expectedR && c === expectedC) {
          currentStep++;
          tracePath.push([r, c]);
          drawTrace();
        }
      }
    }

    function handleEnd(e) {
      isDragging = false;
    }

    function restartGame() {
      path = generateHamiltonianPath();
      numberedPoints = selectNumberedPoints(path, steps);
      currentStep = 0;
      tracePath = [];
      createGrid();
      renderPoints();
    }

    restartGame();
  </script>
</body>
</html>
