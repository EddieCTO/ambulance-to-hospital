<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zip to Hospital Game</title>
  <style>
    body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
    #game { display: grid; grid-template-columns: repeat(6, 60px); grid-template-rows: repeat(6, 60px); gap: 2px; margin-top: 20px; touch-action: none; position: relative; }
    .cell { width: 60px; height: 60px; background: #f0f0f0; display: flex; justify-content: center; align-items: center; border: 1px solid #ccc; font-weight: bold; font-size: 18px; position: relative; user-select: none; }
    .numbered { background: #d9faff; }
    .visited { background: #88ff88; }
    .current { background: #ffe066; }
    .invalid { background: #ff6b6b; }
    .solution-step { background: #ccffcc; transition: background 0.2s ease; }
    #controls { margin-top: 10px; }
    canvas {
      position: absolute;
      pointer-events: none;
      z-index: 0;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>
<h2>Zip to Hospital</h2>
<div id="controls">
  Difficulty: 
  <select id="difficulty">
    <option value="8">8 Steps</option>
    <option value="10">10 Steps</option>
    <option value="12">12 Steps</option>
  </select>
  <button id="restart">Restart</button>
  <button id="hint">Hint</button>
  <span id="timer">Time: 0.00s</span>
</div>
<div id="game"></div>
<canvas id="traceCanvas" width="360" height="360"></canvas>
<div id="message"></div>

<script>
(() => {
  const size = 6;
  const game = document.getElementById("game");
  const canvas = document.getElementById("traceCanvas");
  const ctx = canvas.getContext("2d");
  const message = document.getElementById("message");
  const restartBtn = document.getElementById("restart");
  const hintBtn = document.getElementById("hint");
  const difficultySelect = document.getElementById("difficulty");
  const timerDisplay = document.getElementById("timer");

  let grid = [], solutionPath = [], numberedPoints = [];
  let visitedPath = [], visitedSet = new Set();
  let currentIndex = 0;
  let dragging = false, timerInterval = null, startTime = 0;

  function positionCanvas() {
    const rect = game.getBoundingClientRect();
    canvas.style.left = `${rect.left + window.scrollX}px`;
    canvas.style.top = `${rect.top + window.scrollY}px`;
  }

  window.addEventListener("resize", positionCanvas);
  window.addEventListener("scroll", positionCanvas);

  function createGrid() {
    game.innerHTML = '';
    grid = [];
    for (let r = 0; r < size; r++) {
      const row = [];
      for (let c = 0; c < size; c++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        cell.dataset.r = r;
        cell.dataset.c = c;
        game.appendChild(cell);
        row.push(cell);
      }
      grid.push(row);
    }
  }

  function generateHamiltonianPath() {
    const visited = Array.from({ length: size }, () => Array(size).fill(false));
    const path = [];

    function backtrack(r, c) {
      if (path.length === size * size) return true;
      const directions = [[0,1],[1,0],[0,-1],[-1,0]].sort(() => Math.random() - 0.5);
      for (let [dr, dc] of directions) {
        const nr = r + dr, nc = c + dc;
        if (nr >= 0 && nr < size && nc >= 0 && nc < size && !visited[nr][nc]) {
          visited[nr][nc] = true;
          path.push([nr, nc]);
          if (backtrack(nr, nc)) return true;
          path.pop();
          visited[nr][nc] = false;
        }
      }
      return false;
    }

    while (true) {
      const sr = Math.floor(Math.random() * size);
      const sc = Math.floor(Math.random() * size);
      path.length = 0;
      path.push([sr, sc]);
      visited[sr][sc] = true;
      if (backtrack(sr, sc)) return path;
      visited[sr][sc] = false;
    }
  }

  function selectNumberedPoints(path, count) {
    const points = [];
    const step = Math.floor(path.length / count);
    for (let i = 0; i < count - 1; i++) points.push(path[i * step]);
    points.push(path[path.length - 1]); // Hospital at end
    return points;
  }

  function renderPoints() {
    for (let i = 0; i < numberedPoints.length; i++) {
      const [r, c] = numberedPoints[i];
      const cell = grid[r][c];
      cell.classList.add("numbered");
      cell.textContent = i === 0 ? "ðŸš‘" : (i === numberedPoints.length - 1 ? "ðŸ¥" : i + 1);
    }
  }

  function drawTrace() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();
    for (let i = 0; i < visitedPath.length; i++) {
      const [r, c] = visitedPath[i];
      const x = c * 60 + 30, y = r * 60 + 30;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 3;
    ctx.stroke();
  }

  function showSolutionAnimated() {
    let i = 0;
    function step() {
      if (i >= solutionPath.length) return;
      const [r, c] = solutionPath[i++];
      grid[r][c].classList.add("solution-step");
      setTimeout(step, 30);
    }
    step();
  }

  function startTimer() {
    startTime = performance.now();
    timerInterval = setInterval(() => {
      const elapsed = (performance.now() - startTime) / 1000;
      timerDisplay.textContent = `Time: ${elapsed.toFixed(2)}s`;
    }, 100);
  }

  function stopTimer() {
    clearInterval(timerInterval);
  }

  function resetGame() {
    createGrid();
    const n = +difficultySelect.value;
    solutionPath = generateHamiltonianPath();
    numberedPoints = selectNumberedPoints(solutionPath, n);
    renderPoints();
    visitedPath = [], visitedSet.clear(), currentIndex = 0;
    message.textContent = '';
    stopTimer(); timerDisplay.textContent = 'Time: 0.00s';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    positionCanvas();
  }

  function handleMove(r, c) {
    const key = `${r},${c}`;
    if (visitedSet.has(key)) return;

    if (visitedPath.length > 0) {
      const [lr, lc] = visitedPath[visitedPath.length - 1];
      if (Math.abs(r - lr) + Math.abs(c - lc) !== 1) return;
    }

    visitedPath.push([r, c]);
    visitedSet.add(key);
    const cell = grid[r][c];
    cell.classList.add("visited");
    drawTrace();

    const [expectedR, expectedC] = numberedPoints[currentIndex];
    if (r === expectedR && c === expectedC) {
      currentIndex++;
      if (currentIndex === numberedPoints.length && visitedPath.length === size * size) {
        message.textContent = `ðŸŽ‰ Success! Time: ${(performance.now() - startTime).toFixed(0)/1000}s`;
        stopTimer(); dragging = false;
      }
    } else if (cell.textContent !== "") {
      cell.classList.add("invalid");
      message.textContent = `âŒ Wrong number order!`;
      stopTimer(); dragging = false;
      showSolutionAnimated();
    }
  }

  game.addEventListener("mousedown", (e) => {
    if (e.target.classList.contains("cell")) {
      resetTrace();
      dragging = true;
      startTimer();
      const r = +e.target.dataset.r, c = +e.target.dataset.c;
      handleMove(r, c);
    }
  });

  game.addEventListener("mousemove", (e) => {
    if (!dragging) return;
    const cell = e.target;
    if (!cell.classList.contains("cell")) return;
    const r = +cell.dataset.r, c = +cell.dataset.c;
    handleMove(r, c);
  });

  game.addEventListener("mouseup", () => dragging = false);
  game.addEventListener("mouseleave", () => dragging = false);
  game.addEventListener("touchstart", (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const cell = document.elementFromPoint(touch.clientX, touch.clientY);
    if (cell && cell.classList.contains("cell")) {
      resetTrace();
      dragging = true;
      startTimer();
      handleMove(+cell.dataset.r, +cell.dataset.c);
    }
  }, { passive: false });

  game.addEventListener("touchmove", (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const cell = document.elementFromPoint(touch.clientX, touch.clientY);
    if (cell && cell.classList.contains("cell") && dragging) {
      handleMove(+cell.dataset.r, +cell.dataset.c);
    }
  }, { passive: false });

  function resetTrace() {
    visitedPath = [];
    visitedSet.clear();
    for (let row of grid) {
      for (let cell of row) {
        cell.classList.remove("visited", "invalid", "solution-step");
      }
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    currentIndex = 0;
    message.textContent = '';
  }

  restartBtn.onclick = resetGame;
  difficultySelect.onchange = resetGame;
  hintBtn.onclick = () => {
    stopTimer();
    showSolutionAnimated();
    message.textContent = 'ðŸ§  Hint: Follow the light green path';
  };

  resetGame();
})();
</script>
</body>
</html>
